/*
 * DrakkarKeel - An Enterprise Collaborative Search Platform
 *
 * The contents of this file are subject under the terms described in the
 * DRAKKARKEEL_LICENSE file included in this distribution; you may not use this
 * file except in compliance with the License. 
 *
 * 2013-2014 DrakkarKeel Platform.
 */

package drakkar.cover.swing;

import drakkar.oar.util.OutputMonitor;
import java.awt.Graphics;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedInputStream;
import java.io.IOException;
import javax.swing.ImageIcon;
import javax.swing.JPanel;
import javax.swing.SwingWorker;
import javax.swing.Timer;

public class JAnimator extends JPanel implements ActionListener {

    private int loopslot = -1;  //the current frame number
    private String dir;         //the directory relative to the codebase from which the images are loaded
    private Timer timer;        //the timer animating the images
    private int pause;          //the length of the pause between revs
    private int offset;         //how much to offset between loops
    private int off;            //the current offset
    private int imgHeight;
    private int speed;          //animation speed
    private int nimgs;          //number of images to animate
    private int width;          //width of the component content pane
    private ImageIcon imgs[];   //the images
    private int maxWidth;       //width of widest image
    private String imgPrefix;   // prefix images
    private String imgExt;      // extension images

    /** Creates new form JAnimator */
    public JAnimator() {
        initComponents();
        this.dir = "/drakkar/cover/resources";
        this.imgExt = "png";
        this.imgPrefix = "item";
        this.pause = 1000;
        this.offset = 0;
        this.speed = 100;
        this.nimgs = 2;
        this.maxWidth = 0;

        //Set up timer to drive animation events.
        this.timer = new Timer(speed, this);
        this.timer.setInitialDelay(pause);

        //Start loading the images in the background.
        this.worker.execute();
    }

    /**
     *
     * @param dir
     * @param nimgs
     * @param imgPrefix
     * @param imgExt
     */
    public JAnimator(String dir, int nimgs, String imgPrefix, String imgExt) {
        this.dir = dir;
        this.nimgs = nimgs;
        this.imgPrefix = imgPrefix;
        this.imgExt = imgExt;

        //Set up timer to drive animation events.       
        this.timer = new Timer(speed, this);
        this.timer.setInitialDelay(pause);

        //Start loading the images in the background.
        this.worker.execute();

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (worker.isDone()
                && (loopslot > -1) && (loopslot < nimgs)) {
            if (imgs != null && imgs[loopslot] != null) {
                imgs[loopslot].paintIcon(this, g, off, getHeight() - imgHeight);
            }
        }
    }
    //Background task for loading images.
    SwingWorker worker = new SwingWorker<ImageIcon[], Void>() {

        @Override
        public ImageIcon[] doInBackground() {
            final ImageIcon[] innerImgs = new ImageIcon[nimgs];
            for (int i = 0; i < nimgs; i++) {
                innerImgs[i] = loadImage(i + 1);
            }

            ImageIcon icon = innerImgs[0];
            imgHeight = (icon != null) ? icon.getIconHeight() : 0;
            return innerImgs;
        }

        @Override
        public void done() {
            loopslot = -1;
            try {
                imgs = get();
            } catch (    Exception ex) {
                OutputMonitor.printStream("", ex);
            }
        }
    };

    /**
     *
     */
    public void start() {
        if (worker.isDone() && (nimgs > 1)) {
            timer.start();
        }
    }

    /**
     *
     */
    public void stop() {
        timer.stop();
    }

    /**
     * Load the image for the specified frame of animation. Since
     * this runs as an applet, we use getResourceAsStream for
     * efficiency and so it'll work in older versions of Java Plug-in.
     * @param imageNum
     * @return
     */
    protected ImageIcon loadImage(int imageNum) {
        String path = dir + "/" + imgPrefix + imageNum + "." + imgExt;
        int MAX_IMAGE_SIZE = 2400;  //Change this to the size of
        //your biggest image, in bytes.
        int count = 0;
        BufferedInputStream imgStream = new BufferedInputStream(
                this.getClass().getResourceAsStream(path));
        if (imgStream != null) {
            byte buf[] = new byte[MAX_IMAGE_SIZE];
            try {
                count = imgStream.read(buf);
                imgStream.close();
            } catch (IOException ex) {

                return null;
            }
            if (count <= 0) {
                return null;
            }
            return new ImageIcon(Toolkit.getDefaultToolkit().createImage(buf));
        } else {

            return null;
        }
    }

    //Handle timer event. Update the loopslot (frame number) and the
    //offset.  If it's the last frame, restart the timer to get a long
    //pause between loops.
    public void actionPerformed(ActionEvent e) {
        //If still loading, can't animate.
        if (!worker.isDone()) {
            return;
        }

        loopslot++;

        if (loopslot >= nimgs) {
            loopslot = 0;
            off += offset;

            if (off < 0) {
                off = width - maxWidth;

            } else if (off + maxWidth > width) {
                off = 0;
            }
        }

        this.repaint();

        if (loopslot == nimgs - 1) {
            timer.restart();
        }
    }

    /**
     *
     * @return
     */
    public String getDir() {
        return dir;
    }

    /**
     *
     * @param dir
     */
    public void setDir(String dir) {
        this.dir = dir;
    }

    /**
     *
     * @return
     */
    public String getImgExt() {
        return imgExt;
    }

    /**
     *
     * @param imgExt
     */
    public void setImgExt(String imgExt) {
        this.imgExt = imgExt;
    }

    /**
     *
     * @return
     */
    public String getImgPrefix() {
        return imgPrefix;
    }

    /**
     *
     * @param imgPrefix
     */
    public void setImgPrefix(String imgPrefix) {
        this.imgPrefix = imgPrefix;
    }

    /**
     *
     * @return
     */
    public int getLoopSlot() {
        return loopslot;
    }

    /**
     *
     * @param loopslot
     */
    public void setLoopSlot(int loopslot) {
        this.loopslot = loopslot;
    }

    /**
     *
     * @return
     */
    public int getOff() {
        return off;
    }

    /**
     *
     * @param off
     */
    public void setOff(int off) {
        this.off = off;
    }

    /**
     *
     * @return
     */
    public int getOffset() {
        return offset;
    }

    /**
     *
     * @param offset
     */
    public void setOffset(int offset) {
        this.offset = offset;
    }

    /**
     *
     * @return
     */
    public int getPause() {
        return pause;
    }

    /**
     *
     * @param pause
     */
    public void setPause(int pause) {
        this.pause = pause;
    }

    /**
     *
     * @return
     */
    public int getSpeed() {
        return speed;
    }

    /**
     *
     * @param speed
     */
    public void setSpeed(int speed) {
        this.speed = speed;
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
